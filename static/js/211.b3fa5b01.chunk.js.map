{"version":3,"file":"static/js/211.b3fa5b01.chunk.js","mappings":"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","sources":["../node_modules/hast-util-parse-selector/lib/index.js","../node_modules/hastscript/lib/create-h.js","../node_modules/hastscript/lib/svg-case-sensitive-tag-names.js","../node_modules/hastscript/lib/index.js","../node_modules/rehype-document/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('property-information').Info} Info\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef {Element | Root} Result\n *   Result from a `h` (or `s`) call.\n *\n * @typedef {number | string} StyleValue\n *   Value for a CSS style field.\n * @typedef {Record<string, StyleValue>} Style\n *   Supported value of a `style` prop.\n * @typedef {boolean | number | string | null | undefined} PrimitiveValue\n *   Primitive property value.\n * @typedef {Array<number | string>} ArrayValue\n *   List of property values for space- or comma separated values (such as `className`).\n * @typedef {ArrayValue | PrimitiveValue} PropertyValue\n *   Primitive value or list value.\n * @typedef {{[property: string]: PropertyValue | Style}} Properties\n *   Acceptable value for element properties.\n *\n * @typedef {number | string | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<ArrayChildNested | Nodes | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Array<Nodes | PrimitiveChild>} ArrayChildNested\n *   List of children (deep).\n * @typedef {ArrayChild | Nodes | PrimitiveChild} Child\n *   Acceptable child value.\n */\n\nimport {parse as commas} from 'comma-separated-tokens'\nimport {parseSelector} from 'hast-util-parse-selector'\nimport {find, normalize} from 'property-information'\nimport {parse as spaces} from 'space-separated-tokens'\n\nconst buttonTypes = new Set(['button', 'menu', 'reset', 'submit'])\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {Schema} schema\n *   Schema to use.\n * @param {string} defaultTagName\n *   Default tag name.\n * @param {Array<string> | undefined} [caseSensitive]\n *   Case-sensitive tag names (default: `undefined`).\n * @returns\n *   `h`.\n */\nexport function createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive && createAdjustMap(caseSensitive)\n\n  /**\n   * Hyperscript compatible DSL for creating virtual hast trees.\n   *\n   * @overload\n   * @param {null | undefined} [selector]\n   * @param {...Child} children\n   * @returns {Root}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {Properties} properties\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @overload\n   * @param {string} selector\n   * @param {...Child} children\n   * @returns {Element}\n   *\n   * @param {string | null | undefined} [selector]\n   *   Selector.\n   * @param {Child | Properties | null | undefined} [properties]\n   *   Properties (or first child) (default: `undefined`).\n   * @param {...Child} children\n   *   Children.\n   * @returns {Result}\n   *   Result.\n   */\n  function h(selector, properties, ...children) {\n    let index = -1\n    /** @type {Result} */\n    let node\n\n    if (selector === undefined || selector === null) {\n      node = {type: 'root', children: []}\n      // Properties are not supported for roots.\n      const child = /** @type {Child} */ (properties)\n      children.unshift(child)\n    } else {\n      node = parseSelector(selector, defaultTagName)\n      // Normalize the name.\n      node.tagName = node.tagName.toLowerCase()\n      if (adjust && own.call(adjust, node.tagName)) {\n        node.tagName = adjust[node.tagName]\n      }\n\n      // Handle props.\n      if (isProperties(properties, node.tagName)) {\n        /** @type {string} */\n        let key\n\n        for (key in properties) {\n          if (own.call(properties, key)) {\n            addProperty(schema, node.properties, key, properties[key])\n          }\n        }\n      } else {\n        children.unshift(properties)\n      }\n    }\n\n    // Handle children.\n    while (++index < children.length) {\n      addChild(node.children, children[index])\n    }\n\n    if (node.type === 'element' && node.tagName === 'template') {\n      node.content = {type: 'root', children: node.children}\n      node.children = []\n    }\n\n    return node\n  }\n\n  return h\n}\n\n/**\n * Check if something is properties or a child.\n *\n * @param {Child | Properties} value\n *   Value to check.\n * @param {string} name\n *   Tag name.\n * @returns {value is Properties}\n *   Whether `value` is a properties object.\n */\nfunction isProperties(value, name) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  if (name === 'input' || !value.type || typeof value.type !== 'string') {\n    return true\n  }\n\n  if ('children' in value && Array.isArray(value.children)) {\n    return false\n  }\n\n  if (name === 'button') {\n    return buttonTypes.has(value.type.toLowerCase())\n  }\n\n  return !('value' in value)\n}\n\n/**\n * @param {Schema} schema\n *   Schema.\n * @param {Properties} properties\n *   Properties object.\n * @param {string} key\n *   Property name.\n * @param {PropertyValue | Style} value\n *   Property value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key)\n  let index = -1\n  /** @type {PropertyValue} */\n  let result\n\n  // Ignore nullish and NaN values.\n  if (value === undefined || value === null) return\n\n  if (typeof value === 'number') {\n    // Ignore NaN.\n    if (Number.isNaN(value)) return\n\n    result = value\n  }\n  // Booleans.\n  else if (typeof value === 'boolean') {\n    result = value\n  }\n  // Handle list values.\n  else if (typeof value === 'string') {\n    if (info.spaceSeparated) {\n      result = spaces(value)\n    } else if (info.commaSeparated) {\n      result = commas(value)\n    } else if (info.commaOrSpaceSeparated) {\n      result = spaces(commas(value).join(' '))\n    } else {\n      result = parsePrimitive(info, info.property, value)\n    }\n  } else if (Array.isArray(value)) {\n    result = value.concat()\n  } else {\n    result = info.property === 'style' ? style(value) : String(value)\n  }\n\n  if (Array.isArray(result)) {\n    /** @type {Array<number | string>} */\n    const finalResult = []\n\n    while (++index < result.length) {\n      // Assume no booleans in array.\n      const value = /** @type {number | string} */ (\n        parsePrimitive(info, info.property, result[index])\n      )\n      finalResult[index] = value\n    }\n\n    result = finalResult\n  }\n\n  // Class names (which can be added both on the `selector` and here).\n  if (info.property === 'className' && Array.isArray(properties.className)) {\n    // Assume no booleans in `className`.\n    const value = /** @type {number | string} */ (result)\n    result = properties.className.concat(value)\n  }\n\n  properties[info.property] = result\n}\n\n/**\n * @param {Array<RootContent>} nodes\n *   Children.\n * @param {Child} value\n *   Child.\n * @returns {undefined}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new Error('Expected node, nodes, or string, got `' + value + '`')\n  }\n}\n\n/**\n * Parse a single primitives.\n *\n * @param {Info} info\n *   Property information.\n * @param {string} name\n *   Property name.\n * @param {PrimitiveValue} value\n *   Property value.\n * @returns {PrimitiveValue}\n *   Property value.\n */\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === 'string') {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value)\n    }\n\n    if (\n      (info.boolean || info.overloadedBoolean) &&\n      (value === '' || normalize(value) === normalize(name))\n    ) {\n      return true\n    }\n  }\n\n  return value\n}\n\n/**\n * Serialize a `style` object as a string.\n *\n * @param {Style} value\n *   Style object.\n * @returns {string}\n *   CSS string.\n */\nfunction style(value) {\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {string} */\n  let key\n\n  for (key in value) {\n    if (own.call(value, key)) {\n      result.push([key, value[key]].join(': '))\n    }\n  }\n\n  return result.join('; ')\n}\n\n/**\n * Create a map to adjust casing.\n *\n * @param {Array<string>} values\n *   List of properly cased keys.\n * @returns {Record<string, string>}\n *   Map of lowercase keys to uppercase keys.\n */\nfunction createAdjustMap(values) {\n  /** @type {Record<string, string>} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    result[values[index].toLowerCase()] = values[index]\n  }\n\n  return result\n}\n","export const svgCaseSensitiveTagNames = [\n  'altGlyph',\n  'altGlyphDef',\n  'altGlyphItem',\n  'animateColor',\n  'animateMotion',\n  'animateTransform',\n  'clipPath',\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n  'foreignObject',\n  'glyphRef',\n  'linearGradient',\n  'radialGradient',\n  'solidColor',\n  'textArea',\n  'textPath'\n]\n","/**\n * @typedef {import('./create-h.js').Child} Child\n *   Acceptable child value.\n * @typedef {import('./create-h.js').Properties} Properties\n *   Acceptable value for element properties.\n * @typedef {import('./create-h.js').Result} Result\n *   Result from a `h` (or `s`) call.\n */\n\n// Register the JSX namespace on `h`.\n/**\n * @typedef {import('./jsx-classic.js').Element} h.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} h.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} h.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} h.JSX.IntrinsicElements\n */\n\n// Register the JSX namespace on `s`.\n/**\n * @typedef {import('./jsx-classic.js').Element} s.JSX.Element\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} s.JSX.ElementChildrenAttribute\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} s.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} s.JSX.IntrinsicElements\n */\n\nimport {html, svg} from 'property-information'\nimport {createH} from './create-h.js'\nimport {svgCaseSensitiveTagNames} from './svg-case-sensitive-tag-names.js'\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const h = createH(html, 'div')\n\n// Note: this explicit type is needed, otherwise TS creates broken types.\n/** @type {ReturnType<createH>} */\nexport const s = createH(svg, 'g', svgCaseSensitiveTagNames)\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('hastscript').Properties} Properties\n *\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Array<string> | string | null | undefined} [css]\n *   URLs to stylesheets to use in `<link>`s (optional).\n * @property {'auto' | 'ltr' | 'rtl' | null | undefined} [dir]\n *   Direction of the document (optional).\n * @property {Array<string> | string | null | undefined} [js]\n *   URLs to scripts to use as `src` on `<script>`s (optional).\n * @property {string | null | undefined} [language='en']\n *   Language of document (default: `'en'`); should be a\n *   [BCP 47](https://tools.ietf.org/html/bcp47) language tag.\n * @property {Array<Properties> | Properties | null | undefined} [link]\n *   Generate extra `<link>`s with these properties (optional); passed as\n *   `properties` to [`hastscript`](https://github.com/syntax-tree/hastscript)\n *   with `'link'`.\n * @property {Array<Properties> | Properties | null | undefined} [meta]\n *   Generate extra `<meta>`s with these properties (optional); passed as\n *   `properties` to [`hastscript`](https://github.com/syntax-tree/hastscript)\n *   with `'meta'`.\n * @property {boolean | null | undefined} [responsive=true]\n *   Generate a `meta[viewport]` (default: `true`).\n * @property {Array<string> | string | null | undefined} [script]\n *   JavaScript source code of `<script>`s to add at end of `body` (optional).\n * @property {Array<string> | string | null | undefined} [style]\n *   CSS source code of `<style>`s to add (optional).\n * @property {string | null | undefined} [title]\n *   Text to use as title (optional); defaults to the file name (if any); can\n *   bet set with `file.data.matter.title` (`vfile-matter`) and\n *   `file.data.meta.title` (`rehype-infer-title-meta`), which are preferred.\n */\n\nimport {h} from 'hastscript'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Wrap a fragment in a document.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeDocument(options) {\n  const settings = options || emptyOptions\n  const css = toList(settings.css)\n  const dir = settings.dir\n  const js = toList(settings.js)\n  const language = settings.language || 'en'\n  const link = toList(settings.link)\n  let meta = toList(settings.meta)\n  const script = toList(settings.script)\n  const style = toList(settings.style)\n  const title = settings.title\n\n  if (settings.responsive !== false) {\n    meta = [\n      {content: 'width=device-width, initial-scale=1', name: 'viewport'},\n      ...meta\n    ]\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @param {VFile} file\n   *   File.\n   * @returns {Root}\n   *   New tree.\n   */\n  return function (tree, file) {\n    const titleText =\n      file.data.meta?.title || file.data.matter?.title || title || file.stem\n    /** @type {Array<Nodes>} */\n    const contents = tree.type === 'root' ? [...tree.children] : [tree]\n    /** @type {Array<ElementContent>} */\n    const head = [{type: 'text', value: '\\n'}, h('meta', {charSet: 'utf-8'})]\n    let index = -1\n\n    if (contents.length > 0) {\n      contents.unshift({type: 'text', value: '\\n'})\n    }\n\n    if (titleText) {\n      head.push({type: 'text', value: '\\n'}, h('title', titleText))\n    }\n\n    while (++index < meta.length) {\n      head.push({type: 'text', value: '\\n'}, h('meta', meta[index]))\n    }\n\n    index = -1\n\n    while (++index < link.length) {\n      head.push({type: 'text', value: '\\n'}, h('link', link[index]))\n    }\n\n    // Inject style tags after linked CSS\n    index = -1\n\n    while (++index < style.length) {\n      head.push({type: 'text', value: '\\n'}, h('style', style[index]))\n    }\n\n    index = -1\n\n    while (++index < css.length) {\n      head.push(\n        {type: 'text', value: '\\n'},\n        h('link', {href: css[index], rel: 'stylesheet'})\n      )\n    }\n\n    head.push({type: 'text', value: '\\n'})\n\n    // Inject script tags before linked JS\n    index = -1\n\n    while (++index < script.length) {\n      contents.push({type: 'text', value: '\\n'}, h('script', script[index]))\n    }\n\n    index = -1\n\n    while (++index < js.length) {\n      contents.push({type: 'text', value: '\\n'}, h('script', {src: js[index]}))\n    }\n\n    contents.push({type: 'text', value: '\\n'})\n\n    return {\n      type: 'root',\n      children: [\n        {type: 'doctype'},\n        {type: 'text', value: '\\n'},\n        h('html', {dir, lang: language}, [\n          {type: 'text', value: '\\n'},\n          h('head', head),\n          {type: 'text', value: '\\n'},\n          h('body', contents),\n          {type: 'text', value: '\\n'}\n        ]),\n        {type: 'text', value: '\\n'}\n      ]\n    }\n  }\n}\n\n/**\n * Cast `value` to a list.\n *\n * @template Thing\n *   Value kind.\n * @param {Array<Thing> | Thing | null | undefined} value\n *   Value to cast.\n * @returns {Array<Thing>}\n *   List.\n */\nfunction toList(value) {\n  return value === null || value === undefined\n    ? []\n    : Array.isArray(value)\n      ? value\n      : [value]\n}\n"],"names":["search","buttonTypes","Set","own","hasOwnProperty","createH","schema","defaultTagName","caseSensitive","adjust","values","result","index","length","toLowerCase","createAdjustMap","selector","properties","node","_len","arguments","children","Array","_key","undefined","type","child","unshift","value","props","previous","tagName","start","lastIndex","match","exec","subvalue","slice","id","isArray","className","push","parseSelector","call","name","has","isProperties","key","addProperty","addChild","content","info","find","Number","isNaN","spaceSeparated","spaces","commaSeparated","commas","commaOrSpaceSeparated","join","parsePrimitive","property","concat","style","String","finalResult","nodes","Error","number","boolean","overloadedBoolean","normalize","h","html","emptyOptions","svg","rehypeDocument","options","settings","css","toList","dir","js","language","link","meta","script","title","responsive","tree","file","titleText","data","matter","stem","contents","head","charSet","href","rel","src","lang"],"sourceRoot":""}